import{GLTFLoader,SVGLoader,THREE}from"./three-bundle.js";const e=new GLTFLoader,a=new SVGLoader,r=new THREE.TextureLoader;function t(e){const a=e.getProp("lightPosition");return new THREE.ShaderMaterial({uniforms:{uBackgroundTexture:{value:null},uEnvMap:{value:null},uEnvMapIntensity:{value:e.getProp("environmentMapIntensity")??0},uResolution:{value:new THREE.Vector2(1,1)},uIOR:{value:e.getProp("glassIOR")??1.5},uThickness:{value:e.getProp("glassThickness")??.5},uBlur:{value:e.getProp("glassRoughness")??0},uTint:{value:new THREE.Color(e.getProp("glassTint")||"#ffffff")},uDispersion:{value:e.getProp("glassDispersion")??0},uCameraPosition:{value:new THREE.Vector3(0,0,5)},uLightPosition:{value:new THREE.Vector3((null==a?void 0:a.x)??.75,(null==a?void 0:a.y)??.75,(null==a?void 0:a.z)??.75)},uMetalness:{value:e.getProp("materialMetalness")??.5},uRoughness:{value:e.getProp("materialRoughness")??.5},uLightIntensity:{value:e.getProp("lightIntensity")??.2},uAmbientLightIntensity:{value:e.getProp("ambientLightIntensity")??.75}},vertexShader:"\n  varying vec3 vWorldNormal;\n  varying vec3 vWorldPosition;\n  varying vec4 vClipPosition;\n  \n  void main() {\n    vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    vClipPosition = clipPos;\n    gl_Position = clipPos;\n  }\n",fragmentShader:"\n  uniform sampler2D uBackgroundTexture;\n  uniform sampler2D uEnvMap;\n  uniform float uEnvMapIntensity;\n  uniform vec2 uResolution;\n  uniform float uIOR;\n  uniform float uThickness;\n  uniform float uBlur;\n  uniform vec3 uTint;\n  uniform float uDispersion;\n  uniform vec3 uCameraPosition;\n  \n  // Lighting uniforms (mirrors Curtains shader)\n  uniform vec3 uLightPosition;\n  uniform float uMetalness;\n  uniform float uRoughness;\n  uniform float uLightIntensity;\n  uniform float uAmbientLightIntensity;\n  \n  varying vec3 vWorldNormal;\n  varying vec3 vWorldPosition;\n  varying vec4 vClipPosition;\n  \n  #define PI 3.14159265359\n  \n  vec3 sampleBackground(vec2 screenUV, vec2 offset) {\n    vec2 uv = clamp(screenUV + offset, 0.001, 0.999);\n    return texture2D(uBackgroundTexture, uv).rgb;\n  }\n  \n  // Sample equirectangular environment map\n  vec3 sampleEnvMap(vec3 direction) {\n    float phi = atan(direction.z, direction.x);\n    float theta = asin(clamp(direction.y, -1.0, 1.0));\n    vec2 uv = vec2(phi / (2.0 * PI) + 0.5, theta / PI + 0.5);\n    return texture2D(uEnvMap, uv).rgb;\n  }\n  \n  void main() {\n    vec3 normal = normalize(vWorldNormal);\n    vec3 viewDir = normalize(uCameraPosition - vWorldPosition);\n    \n    // Handle backface: flip normal for proper refraction on back surfaces\n    float facing = gl_FrontFacing ? 1.0 : -1.0;\n    normal *= facing;\n    \n    vec2 screenUV = (vClipPosition.xy / vClipPosition.w) * 0.5 + 0.5;\n    screenUV.y = 1.0 - screenUV.y;\n    \n    // Calculate refraction using IOR\n    // For backfaces, we're exiting the material so invert the ratio\n    float eta = gl_FrontFacing ? (1.0 / uIOR) : uIOR;\n    vec3 refractDir = refract(-viewDir, normal, eta);\n    \n    // Refraction strength: IOR controls direction, thickness amplifies the offset\n    float iorStrength = abs(uIOR - 1.0) * 0.5;\n    float refractStrength = iorStrength * (0.3 + uThickness * 0.4);\n    vec2 refractOffset = refractDir.xy * refractStrength;\n    \n    vec3 refractedColor;\n    if (uDispersion > 0.001) {\n      float dispersionAmount = uDispersion * 0.02;\n      float etaR = gl_FrontFacing ? (1.0 / (uIOR * (1.0 - dispersionAmount))) : (uIOR * (1.0 - dispersionAmount));\n      float etaG = eta;\n      float etaB = gl_FrontFacing ? (1.0 / (uIOR * (1.0 + dispersionAmount))) : (uIOR * (1.0 + dispersionAmount));\n      \n      vec3 redRefract = refract(-viewDir, normal, etaR);\n      vec3 greenRefract = refract(-viewDir, normal, etaG);\n      vec3 blueRefract = refract(-viewDir, normal, etaB);\n      \n      float r = sampleBackground(screenUV, redRefract.xy * refractStrength).r;\n      float g = sampleBackground(screenUV, greenRefract.xy * refractStrength).g;\n      float b = sampleBackground(screenUV, blueRefract.xy * refractStrength).b;\n      refractedColor = vec3(r, g, b);\n    } else {\n      refractedColor = sampleBackground(screenUV, refractOffset);\n    }\n    \n    if (uBlur > 0.001) {\n      float blurAmount = uBlur * 0.02;\n      vec3 blurred = refractedColor;\n      blurred += sampleBackground(screenUV, refractOffset + vec2(blurAmount, 0.0));\n      blurred += sampleBackground(screenUV, refractOffset + vec2(-blurAmount, 0.0));\n      blurred += sampleBackground(screenUV, refractOffset + vec2(0.0, blurAmount));\n      blurred += sampleBackground(screenUV, refractOffset + vec2(0.0, -blurAmount));\n      refractedColor = blurred / 5.0;\n    }\n    \n    // Apply tint as a subtle color blend (not darkening)\n    refractedColor = mix(refractedColor, refractedColor * uTint, 0.5 + uThickness * 0.3);\n    \n    // === Environment map reflections ===\n    float F0 = pow((uIOR - 1.0) / (uIOR + 1.0), 2.0);\n    float fresnel = F0 + (1.0 - F0) * pow(1.0 - max(dot(normal, viewDir), 0.0), 5.0);\n    \n    vec3 reflectedColor = refractedColor;\n    if (uEnvMapIntensity > 0.001) {\n      vec3 reflectDir = reflect(-viewDir, normal);\n      vec3 envColor = sampleEnvMap(reflectDir) * uEnvMapIntensity;\n      reflectedColor = mix(refractedColor, envColor, fresnel * uEnvMapIntensity);\n    }\n    \n    // === Lighting calculations (mirrors Curtains shader) ===\n    \n    vec3 lightDir = normalize(vec3(uLightPosition.xy * 2.0 - 1.0, uLightPosition.z * 2.0 - 1.0));\n    float shininess = mix(2.0, 64.0, 1.0 - uRoughness);\n    vec3 reflectVec = reflect(-lightDir, normal);\n    float spec = pow(max(dot(reflectVec, viewDir), 0.0), shininess);\n    \n    vec3 specularColor = mix(vec3(1.0), reflectedColor, uMetalness) * uLightIntensity;\n    \n    float rimFresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);\n    vec3 litColor = reflectedColor + specularColor * spec;\n    if (uEnvMapIntensity < 0.001) {\n      litColor += rimFresnel * uAmbientLightIntensity;\n    }\n    \n    gl_FragColor = vec4(litColor, 1.0);\n  }\n",transparent:!0,side:THREE.DoubleSide})}const n=new WeakMap;function o(e){return n.has(e)||n.set(e,{scene:null,camera:null,renderer:null,model:null,ambientLight:null,directionalLight:null,fillLight:null,customNormalMap:null,customEnvMap:null,envMap:null,customColorMap:null,glassMaterial:null,backgroundTexture:null}),n.get(e)}function l(e,a=!1,t=!1){return new Promise(t=>{r.load(e,e=>{a?(e.mapping=THREE.EquirectangularReflectionMapping,e.colorSpace=THREE.SRGBColorSpace,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,e.generateMipmaps=!1):(e.wrapS=e.wrapT=THREE.RepeatWrapping,e.flipY=!0),t(e)})})}function i(e,a,r,t,n="map",o=1,l=1){a.repeat.setScalar(r);const i=-(r-1)/2,s=((null==t?void 0:t.x)??.5)-.5,u=((null==t?void 0:t.y)??.5)-.5;a.offset.set(i+s,i+u),e.model.traverse(e=>{e.isMesh&&(Array.isArray(e.material)?e.material:[e.material]).forEach(e=>{(e.isMeshStandardMaterial||e.isMeshPhongMaterial||e.isMeshLambertMaterial)&&("map"===n?(e.map=a,e.color&&e.color.setScalar(l)):"normalMap"===n&&void 0!==e.normalMap&&(e.normalMap=a,e.normalScale&&e.normalScale.set(o,-o)),e.needsUpdate=!0)})})}function s(e,a,r){var t;a&&e.model&&(null==(t=e.model.userData.materials)||t.forEach(e=>{(e.isMeshStandardMaterial||e.isMeshPhysicalMaterial)&&(e.envMap=a,e.envMapIntensity=r,e.needsUpdate=!0)}))}function initialize(e,a){const r=o(a),t=e.canvas?e.canvas.width:e.drawingBufferWidth,n=e.canvas?e.canvas.height:e.drawingBufferHeight;if(0===t||0===n)return;r.scene=new THREE.Scene,r.camera=new THREE.PerspectiveCamera(35,t/n,.1,100),r.camera.position.set(0,0,5),r.renderer=new THREE.WebGLRenderer({canvas:e.canvas,context:e,alpha:!0,preserveDrawingBuffer:!1,premultipliedAlpha:!0,logarithmicDepthBuffer:!0,antialias:"high"===a.quality}),r.renderer.setClearColor(0,0),r.renderer.outputColorSpace=THREE.SRGBColorSpace,function(e,a){e.renderer&&(e.renderer.toneMapping=a?THREE.ACESFilmicToneMapping:THREE.NoToneMapping,e.renderer.toneMappingExposure=a?1.5:1,e.renderer.physicallyCorrectLights=a)}(r,"high"===a.quality),r.renderer.setPixelRatio(1),r.renderer.setSize(t,n,!1);const l=a.getProp("ambientLightColor"),i=a.getProp("ambientLightIntensity"),s=a.getProp("lightColor"),u=a.getProp("lightIntensity"),c=a.getProp("fillLightColor"),m=a.getProp("fillLightIntensity"),p=a.getProp("lightPosition");r.ambientLight=new THREE.AmbientLight(l||"#777777",2*(i??.75)),r.scene.add(r.ambientLight),r.directionalLight=new THREE.DirectionalLight(s||"#777777",5*(u??.2)*2),r.scene.add(r.directionalLight),r.fillLight=new THREE.DirectionalLight(c||"#777777",5*(m??.2)*2),r.scene.add(r.fillLight);const g=10*(p.x-.5),d=10*(p.y-.5),h=10*(p.z-.5);r.directionalLight&&r.directionalLight.position.set(g,-d,h),r.fillLight&&r.fillLight.position.set(.8*-g,.8*d,.8*-h)}function loadModel(r){const n=o(r);r.local.modelLoaded=!1,r.local.modelLoading=!1;const u=r.modelUrl.toLowerCase(),c=u.startsWith("data:image/svg+xml");if(u.split("?")[0].endsWith(".svg")||c){const e=e=>{var a,o;const u=e.paths,c=function(e,a,r){const t=new THREE.Group;for(let n=0;n<e.length;n++){const o=e[n],l=o.userData.style.fill;if(void 0!==l&&"none"!==l){const e=new THREE.MeshStandardMaterial({color:(new THREE.Color).setStyle(l),metalness:r.getProp("materialMetalness")??.5,roughness:r.getProp("materialRoughness")??.5,side:THREE.DoubleSide}),n=SVGLoader.createShapes(o);for(let r=0;r<n.length;r++){const o=n[r],l=new THREE.ExtrudeGeometry(o,a),i=l.attributes.position,s=l.attributes.uv;l.computeBoundingBox();const u=l.boundingBox.min,c=l.boundingBox.max,m=c.x-u.x,p=c.y-u.y,g=(e,a,r)=>{for(let t=e;t<e+a;t++){let e=t;if(l.index&&(e=l.index.getX(t)),r){const a=s.getX(e),r=s.getY(e),t=1/Math.max(m,p);s.setXY(e,a*t,r*t)}else{const a=i.getX(e),r=i.getY(e);s.setXY(e,(a-u.x)/m,(r-u.y)/p)}}};l.groups&&l.groups.length>0?l.groups.forEach(e=>{g(e.start,e.count,1===e.materialIndex)}):g(0,l.index?l.index.count:i.count,!1),s.needsUpdate=!0;const d=new THREE.Mesh(l,e);d.scale.set(1,-1,1),t.add(d)}}}return t}(u,{depth:r.getProp("extrudeDepth")??10,bevelEnabled:r.getProp("bevelEnabled")??!1,bevelThickness:r.getProp("bevelThickness")??1,bevelSize:r.getProp("bevelSize")??1,bevelSegments:r.getProp("bevelSegments")??2},r);n.model=c,n.model.userData.isSVG=!0,n.model.userData.svgPaths=u;const m=(new THREE.Box3).setFromObject(n.model),p=m.getCenter(new THREE.Vector3);n.model.position.copy(p).multiplyScalar(-1);const g=m.getSize(new THREE.Vector3),d=Math.max(g.x,g.y,g.z),h=d>0?1/d:1,v=new THREE.Group;v.add(n.model),n.model=v,n.model.userData.baseScale=h,n.model.userData.isSVGWrapper=!0,n.model.userData.materials=[],n.model.userData.textureMaterials=[],n.model.userData.meshes=[],n.model.traverse(e=>{e.isMesh&&(n.model.userData.meshes.push(e),n.model.userData.materials.push(e.material),n.model.userData.textureMaterials.push(e.material),e.material.userData||(e.material.userData={}),e.material.userData.originalMap=null,e.material.userData.originalNormalMap=null)}),r.renderNormals&&n.model.userData.meshes&&(n.glassMaterial||(n.glassMaterial=t(r)),n.model.userData.meshes.forEach(e=>{e.userData.originalMaterial||(e.userData.originalMaterial=e.material,e.material=n.glassMaterial)})),(null==(a=r.colorMapUrl)?void 0:a.trim())&&!r.renderNormals&&l(r.colorMapUrl,!1).then(e=>{const a=Math.max(.001,r.getProp("colorMapScale")??1),t=r.getProp("colorMapIntensity")??1;i(n,e,a,r.getProp("colorMapPosition"),"map",1,t),n.customColorMap=e}),(null==(o=r.normalMapUrl)?void 0:o.trim())&&!r.renderNormals&&l(r.normalMapUrl,!1,!0).then(e=>{const a=Math.max(.001,r.getProp("normalMapScale")??1);i(n,e,a,r.getProp("normalMapPosition"),"normalMap",r.getProp("normalMapIntensity")),n.customNormalMap=e}),n.customEnvMap&&r.environmentMapIntensity>0&&s(n,n.customEnvMap,r.environmentMapIntensity),n.scene.add(n.model),r.handleModelLoaded()};if(c)try{const t=r.modelUrl.split(",")[1],n=decodeURIComponent(escape(atob(t)));e(a.parse(n))}catch(m){console.error("An error occurred while parsing the SVG data URL:",m),r.local.modelLoading=!1}else a.load(r.modelUrl,e,e=>{e.total>0&&console.log(e.loaded/e.total*100+"% loaded")},e=>{console.error("An error occurred while loading the SVG:",e),r.local.modelLoading=!1})}else e.load(r.modelUrl,e=>{var a;n.model=e.scene;const o=(new THREE.Box3).setFromObject(n.model),u=o.getCenter(new THREE.Vector3);n.model.position.copy(u).multiplyScalar(-1);const c=o.getSize(new THREE.Vector3),m=Math.max(c.x,c.y,c.z),p=m>0?1/m:1,g=new THREE.Group;g.add(n.model),n.model=g,n.model.userData.baseScale=p,n.model.userData.materials=[],n.model.userData.meshes=[],n.model.traverse(e=>{if(e.isMesh){n.model.userData.meshes.push(e);const a=Array.isArray(e.material)?e.material:[e.material],t=r.getProp("materialMetalness"),o=r.getProp("materialRoughness");a.forEach((a,r)=>{var l;if((a.isMeshPhongMaterial||a.isMeshLambertMaterial)&&!(null==(l=a.userData)?void 0:l.converted)){const t=function(e){const a=new THREE.MeshStandardMaterial;return a.color.copy(e.color),a.map=e.map,a.normalMap=e.normalMap,a.emissiveMap=e.emissiveMap,a.aoMap=e.aoMap,a.emissive.copy(e.emissive||new THREE.Color(0,0,0)),a.opacity=e.opacity??1,a.transparent=e.transparent??!1,a.side=e.side??THREE.FrontSide,e.userData||(e.userData={}),a.userData=e.userData,a.userData.converted=!0,a}(a);Array.isArray(e.material)?e.material[r]=t:e.material=t,a=t}n.model.userData.materials.push(a),void 0!==a.metalness&&(a.metalnessMap&&(a.metalnessMap=null,a.needsUpdate=!0),a.metalness=t??a.metalness),void 0!==a.roughness&&(a.roughnessMap&&(a.roughnessMap=null,a.needsUpdate=!0),a.roughness=o??a.roughness),(a.isMeshStandardMaterial||a.isMeshPhysicalMaterial)&&(a.envMapIntensity=a.envMapIntensity??1)})}}),r.renderNormals&&(n.glassMaterial||(n.glassMaterial=t(r)),n.model.userData.meshes.forEach(e=>{e.userData.originalMaterial||(e.userData.originalMaterial=e.material),e.material=n.glassMaterial})),r.colorMapUrl&&!r.renderNormals&&(n.model.traverse(e=>{e.isMesh&&(Array.isArray(e.material)?e.material:[e.material]).forEach(e=>{(e.isMeshStandardMaterial||e.isMeshPhongMaterial||e.isMeshLambertMaterial)&&(e.map=null,e.needsUpdate=!0)})}),l(r.colorMapUrl,!1).then(e=>{n.customColorMap=e;const a=r.getProp("colorMapIntensity")??1;i(n,e,Math.max(.001,r.getProp("colorMapScale")),r.getProp("colorMapPosition"),"map",1,a)})),r.normalMapUrl&&!r.renderNormals&&l(r.normalMapUrl,!1,!0).then(e=>{n.customNormalMap=e,i(n,e,Math.max(.001,r.getProp("normalMapScale")),r.getProp("normalMapPosition"),"normalMap",r.getProp("normalMapIntensity"))});const d=r.getProp("environmentMapIntensity");d>0&&(null==(a=r.environmentMapUrl)?void 0:a.trim())&&l(r.environmentMapUrl,!0).then(e=>{n.customEnvMap=e,r.renderNormals||s(n,n.customEnvMap,d)}),n.scene.add(n.model),r.handleModelLoaded()},void 0,e=>{console.error("An error occurred while loading the model:",e)});r.local.modelLoading=!0}function isLoading(e){return e.local.modelLoading&&!e.local.modelLoaded}function draw(e,a,r){var n,l,i,u,c,m,p;const g=o(r);if(!r.local.modelLoaded)return;if(!g.renderer||!g.renderer.getContext()||g.renderer.getContext().isContextLost())return console.warn("Three.js renderer context lost, reinitializing..."),void(r.local.initialized=!1);const d=e.canvas?e.canvas.width:e.drawingBufferWidth,h=e.canvas?e.canvas.height:e.drawingBufferHeight;if(0===d||0===h)return;const v=r.getProp("environmentMapIntensity");if(v>0&&!(null==(n=r.environmentMapUrl)?void 0:n.trim())){const e=r.local.envTexture,a=(null==(l=g.model)?void 0:l.userData.lastEnvMapIntensity)!==v;!e||!a&&g.envMap||function(e,a,r,t,n,o){var l,i,u;if(r&&a)if(e.envMap)e.model.userData.lastEnvMapIntensity!==o&&(null==(u=e.model.userData.materials)||u.forEach(e=>{(e.isMeshStandardMaterial||e.isMeshPhysicalMaterial)&&(e.envMapIntensity=o)}),e.model.userData.lastEnvMapIntensity=o);else{e.envMap=new THREE.Texture,e.envMap.mapping=THREE.EquirectangularReflectionMapping,e.envMap.colorSpace=THREE.SRGBColorSpace,e.envMap.minFilter=THREE.LinearFilter,e.envMap.magFilter=THREE.LinearFilter,e.envMap.generateMipmaps=!1,e.envMap.flipY=!1,e.envMap.image={width:t,height:n};const a=e.renderer.properties.get(e.envMap);a.__webglTexture=r,a.__webglInit=!0;const l=e.renderer.info.memory;l&&l.textures++,s(e,e.envMap,o)}else null==(i=null==(l=e.model)?void 0:l.userData.materials)||i.forEach(e=>{e.envMap&&(e.envMap=null,e.needsUpdate=!0)})}(g,e.gl,e.webglTexture,e.width,e.height,v)}let f=0,M=0,x=0,y=0,P=0,b=0;const D=r.getProp("trackMouse"),w=r.getProp("rotationTracking"),L=r.getProp("lightTracking");if(0!=D||0!=w||0!=L){const e=r.local.mouse||{x:.5,y:.5},a=e.x-.5,t=e.y-.5;0!=D&&(f=a*D,M=-t*D),0!=w&&(x=-t*w,y=-a*w),0!=L&&(P=a*L,b=-t*L)}g.camera.userData.dim||(g.camera.userData.dim={}),g.camera.userData.dim.w===d&&g.camera.userData.dim.h===h||(g.camera.aspect=d/h,g.camera.updateProjectionMatrix(),g.renderer.setSize(d,h,!1),g.camera.userData.dim={w:d,h:h});const I=g.scene.userData.lp=g.scene.userData.lp||{};if(!r.renderNormals){const e=r.getProp("ambientLightIntensity"),a=r.getProp("ambientLightColor"),t=r.getProp("lightIntensity"),n=r.getProp("lightColor"),o=r.getProp("fillLightIntensity"),l=r.getProp("fillLightColor");!g.ambientLight||I.ai===e&&I.ac===a||(I.ai!==e&&(g.ambientLight.intensity=2*(e??.75)),I.ac!==a&&g.ambientLight.color.set(a||"#777777"),I.ai=e,I.ac=a),!g.directionalLight||I.li===t&&I.lc===n||(g.directionalLight.intensity=5*(t??.2)*2,g.directionalLight.color.set(n||"#777777"),I.li=t,I.lc=n),!g.fillLight||I.fli===o&&I.flc===l||(g.fillLight.intensity=5*(o??.2)*2,g.fillLight.color.set(l||"#777777"),I.fli=o,I.flc=l);const i=r.getProp("lightPosition"),s=0!=L;if(g.directionalLight&&i&&(s||I.lx!==i.x||I.ly!==i.y||I.lz!==i.z)){const e=10*(i.x+P-.5),a=10*(i.y+b-.5),r=10*(i.z-.5);g.directionalLight.position.set(e,-a,r),g.fillLight.position.set(.8*-e,.8*a,.8*-r),s||(I.lx=i.x,I.ly=i.y,I.lz=i.z)}}if(g.model){const e=g.model.userData.mp=g.model.userData.mp||{};if(!r.renderNormals){const a=r.getProp("materialMetalness"),t=r.getProp("materialRoughness");e.mm===a&&e.mr===t||(null==(i=g.model.userData.materials)||i.forEach(r=>{e.mm!==a&&void 0!==r.metalness&&(r.metalnessMap&&(r.metalnessMap=null,r.needsUpdate=!0),r.metalness=a),e.mr!==t&&void 0!==r.roughness&&(r.roughnessMap&&(r.roughnessMap=null,r.needsUpdate=!0),r.roughness=t)}),e.mm=a,e.mr=t);const n=r.getProp("colorMapScale"),o=r.getProp("colorMapPosition"),l=r.getProp("colorMapIntensity");if(g.customColorMap&&(e.cms!==n||e.cmpx!==(null==o?void 0:o.x)||e.cmpy!==(null==o?void 0:o.y)||e.cmi!==l)){const a=Math.max(.001,n);g.customColorMap.repeat.setScalar(a);const r=-(a-1)/2,t=((null==o?void 0:o.x)??.5)-.5,i=((null==o?void 0:o.y)??.5)-.5;g.customColorMap.offset.set(r+t,r+i);const s=l??1;null==(u=g.model.userData.materials)||u.forEach(e=>{(e.isMeshStandardMaterial||e.isMeshPhongMaterial||e.isMeshLambertMaterial)&&(e.color&&e.color.setScalar(s),e.needsUpdate=!0)}),e.cms=n,e.cmpx=null==o?void 0:o.x,e.cmpy=null==o?void 0:o.y,e.cmi=l}const m=r.getProp("normalMapScale"),p=r.getProp("normalMapPosition"),d=r.getProp("normalMapIntensity");if(g.customNormalMap&&(e.nms!==m||e.nmpx!==(null==p?void 0:p.x)||e.nmpy!==(null==p?void 0:p.y)||e.nmi!==d)){const a=Math.max(.001,m);g.customNormalMap.repeat.setScalar(a);const r=-(a-1)/2,t=((null==p?void 0:p.x)??.5)-.5,n=((null==p?void 0:p.y)??.5)-.5;g.customNormalMap.offset.set(r+t,r+n);const o=d??1;null==(c=g.model.userData.materials)||c.forEach(e=>{void 0!==e.normalMap&&e.normalScale&&(e.normalScale.set(o,-o),e.needsUpdate=!0)}),e.nms=m,e.nmpx=null==p?void 0:p.x,e.nmpy=null==p?void 0:p.y,e.nmi=d}const h=r.getProp("environmentMapIntensity");g.customEnvMap&&e.emi!==h&&(s(g,g.customEnvMap,h),e.emi=h)}const n=g.model.userData.baseScale||1,o=r.getProp("pos"),l=r.getProp("scale");if(e.s!==l){const a=10*l*n;g.model.scale.set(a,a,a),e.s=l}const v=0!==f||0!==M;if(o&&(v||e.px!==o.x||e.py!==o.y||e.pz!==o.z)){const a=8*(o.x-.5+f),r=8*(o.y-.5+M),t=8*(o.z-.5);g.model.position.set(a,-r,t),v||(e.px=o.x,e.py=o.y,e.pz=o.z)}const P=r.getProp("modelRotation"),b=r.getProp("speed"),D=r.getProp("animationAxis"),w=0!==x||0!==y,L=b>0&&r.animating;if(P&&(w||L||e.rx!==P.x||e.ry!==P.y||e.rz!==P.z)){let r=(P.y-.5+x)*Math.PI*2+Math.PI,t=g.model.userData.isSVGWrapper?Math.PI:0,n=(P.x-.5+y)*Math.PI*2+t,o=(P.z-.5)*Math.PI*2;if(L){const e=b*a*.001;D.x>0&&(r+=e*D.x),D.y>0&&(n+=e*D.y),D.z>0&&(o+=e*D.z)}g.model.rotation.set(r,n,o),w||L||(e.rx=P.x,e.ry=P.y,e.rz=P.z)}if(e.rn!==r.renderNormals&&(r.renderNormals?(g.glassMaterial||(g.glassMaterial=t(r)),null==(m=g.model.userData.meshes)||m.forEach(e=>{e.userData.originalMaterial||(e.userData.originalMaterial=e.material),e.material=g.glassMaterial})):null==(p=g.model.userData.meshes)||p.forEach(e=>{e.userData.originalMaterial&&(e.material=e.userData.originalMaterial)}),e.rn=r.renderNormals),r.renderNormals&&g.glassMaterial){const a=r.local.backgroundTexture;a&&(function(e,a,r,t){if(a&&a.webglTexture)if(e.backgroundTexture){const n=e.renderer.properties.get(e.backgroundTexture);n.__webglTexture!==a.webglTexture&&(n.__webglTexture=a.webglTexture),e.backgroundTexture.image.width===r&&e.backgroundTexture.image.height===t||(e.backgroundTexture.image={width:r,height:t})}else{e.backgroundTexture=new THREE.Texture,e.backgroundTexture.minFilter=THREE.LinearFilter,e.backgroundTexture.magFilter=THREE.LinearFilter,e.backgroundTexture.wrapS=THREE.ClampToEdgeWrapping,e.backgroundTexture.wrapT=THREE.ClampToEdgeWrapping,e.backgroundTexture.generateMipmaps=!1,e.backgroundTexture.flipY=!1,e.backgroundTexture.image={width:r,height:t};const n=e.renderer.properties.get(e.backgroundTexture);n.__webglTexture=a.webglTexture,n.__webglInit=!0}}(g,a,a.width,a.height),g.glassMaterial.uniforms.uBackgroundTexture.value=g.backgroundTexture,g.glassMaterial.uniforms.uResolution.value.set(d,h)),g.glassMaterial.uniforms.uCameraPosition.value.copy(g.camera.position);const t=r.getProp("glassIOR")??1.5,n=r.getProp("glassThickness")??.5,o=r.getProp("glassRoughness")??0,l=r.getProp("glassTint")||"#ffffff",i=r.getProp("glassDispersion")??0;e.gior!==t&&(g.glassMaterial.uniforms.uIOR.value=t,e.gior=t),e.gth!==n&&(g.glassMaterial.uniforms.uThickness.value=n,e.gth=n),e.gbl!==o&&(g.glassMaterial.uniforms.uBlur.value=o,e.gbl=o),e.gti!==l&&(g.glassMaterial.uniforms.uTint.value.set(l),e.gti=l),e.gdi!==i&&(g.glassMaterial.uniforms.uDispersion.value=i,e.gdi=i);const s=r.getProp("lightPosition"),u=r.getProp("materialMetalness")??.5,c=r.getProp("materialRoughness")??.5,m=r.getProp("lightIntensity")??.2,p=r.getProp("ambientLightIntensity")??.75;!s||e.glpx===s.x&&e.glpy===s.y&&e.glpz===s.z||(g.glassMaterial.uniforms.uLightPosition.value.set(s.x,s.y,s.z),e.glpx=s.x,e.glpy=s.y,e.glpz=s.z),e.gmet!==u&&(g.glassMaterial.uniforms.uMetalness.value=u,e.gmet=u),e.gmro!==c&&(g.glassMaterial.uniforms.uRoughness.value=c,e.gmro=c),e.gli!==m&&(g.glassMaterial.uniforms.uLightIntensity.value=m,e.gli=m),e.gai!==p&&(g.glassMaterial.uniforms.uAmbientLightIntensity.value=p,e.gai=p);const v=r.getProp("environmentMapIntensity")??0;e.gemi!==v&&(g.glassMaterial.uniforms.uEnvMapIntensity.value=v,e.gemi=v),v>0&&(g.customEnvMap?g.glassMaterial.uniforms.uEnvMap.value=g.customEnvMap:g.envMap&&(g.glassMaterial.uniforms.uEnvMap.value=g.envMap))}}g.renderer.render(g.scene,g.camera),g.renderer.resetState&&g.renderer.resetState()}function dispose(e){var a,r;const t=o(e);if(t.customColorMap&&(t.customColorMap.dispose(),t.customColorMap=null),t.customNormalMap&&(t.customNormalMap.dispose(),t.customNormalMap=null),t.customEnvMap&&(t.customEnvMap.dispose(),t.customEnvMap=null),t.envMap&&(t.envMap.dispose(),t.envMap=null),t.glassMaterial&&(t.glassMaterial.dispose(),t.glassMaterial=null),t.backgroundTexture){const e=null==(r=null==(a=t.renderer)?void 0:a.properties)?void 0:r.get(t.backgroundTexture);e&&(e.__webglTexture=null),t.backgroundTexture.dispose(),t.backgroundTexture=null}t.model&&(t.model.traverse(e=>{e.isMesh&&(e.geometry&&e.geometry.dispose(),Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material&&e.material.dispose())}),t.scene&&t.scene.remove(t.model),t.model=null),t.renderer&&(t.renderer.dispose(),t.renderer=null),t.scene=null,t.camera=null,t.ambientLight=null,t.directionalLight=null,t.fillLight=null,n.delete(e)}export{dispose,draw,initialize,isLoading,loadModel};
